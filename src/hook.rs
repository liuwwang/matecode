//! src/hook.rs

use crate::git::run_git_command;
use anyhow::{anyhow, Result};
use std::env;
use std::fs;
use std::os::unix::fs::PermissionsExt;
use std::path::PathBuf;

fn get_hooks_dir() -> Result<PathBuf> {
    let git_dir_output = run_git_command(&["rev-parse", "--git-dir"])?;
    let git_dir = String::from_utf8(git_dir_output.stdout)?.trim().to_string();
    let hooks_dir = PathBuf::from(git_dir).join("hooks");
    fs::create_dir_all(&hooks_dir)?;
    Ok(hooks_dir)
}

pub fn install_post_commit_hook() -> Result<()> {
    let hooks_dir = get_hooks_dir()?;
    let hook_path = hooks_dir.join("post-commit");

    // 安全检查：如果存在一个不属于 matecode 的钩子，则中止
    if hook_path.exists() {
        let existing_content = fs::read_to_string(&hook_path)?;
        if !existing_content.contains("matecode archive") {
            println!(
                "⚠️  检测到已存在的 post-commit 钩子，但内容与 matecode 无关。\n为避免覆盖现有逻辑，安装已中止。"
            );
            println!(
                "👉 请手动将 `matecode archive` 命令添加到您的 {} 文件中。",
                hook_path.display()
            );
            return Ok(());
        }
    }

    // 获取 matecode 的绝对路径
    let matecode_path = env::current_exe()?;
    let matecode_path_str = matecode_path
        .to_str()
        .ok_or_else(|| anyhow!("无法获取 matecode 可执行文件路径"))?;

    let hook_script_content = format!(
        r#"#!/bin/sh
# matecode post-commit hook
# This script is auto-generated by `matecode install-hook`.

# 使用绝对路径调用 matecode，以确保在任何环境下都能找到
"{}" archive
"#,
        matecode_path_str
    );

    fs::write(&hook_path, hook_script_content)?;

    // 在 Unix 系统上，赋予执行权限
    #[cfg(unix)]
    {
        let mut perms = fs::metadata(&hook_path)?.permissions();
        perms.set_mode(0o755); // rwxr-xr-x
        fs::set_permissions(&hook_path, perms)?;
    }

    println!("✅ post-commit 钩子已成功安装到 {}", hook_path.display());

    Ok(())
} 